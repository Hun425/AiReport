# AI 알고리즘 학습 로드맵 서비스 - 개발 가이드라인

> **CTO 관점에서의 실전 개발 원칙 및 코드 패턴 정리**

## 🏗️ 1. 아키텍처 패턴

### 1.1 Clean Architecture + Layered Architecture 적용

```kotlin
src/
└── main/kotlin/com/roadmap/
    ├── RoadmapApplication.kt
    ├── domain/                    // 비즈니스 로직 (순수 Kotlin)
    │   ├── entity/               // 도메인 엔티티
    │   ├── repository/           // 리포지토리 인터페이스
    │   ├── service/             // 도메인 서비스
    │   └── exception/           // 도메인 예외
    ├── application/             // 애플리케이션 서비스
    │   ├── service/            // 유스케이스 구현
    │   ├── dto/               // 요청/응답 DTO
    │   └── mapper/            // 도메인 ↔ DTO 매핑
    ├── infrastructure/         // 외부 의존성
    │   ├── persistence/       // JPA 엔티티, 리포지토리 구현
    │   ├── external/         // 외부 API 클라이언트
    │   └── config/          // 설정 파일들
    └── presentation/           // 컨트롤러 계층
        ├── controller/        // REST 컨트롤러
        ├── exception/        // 글로벌 예외 처리
        └── filter/          // 인증, 로깅 필터
```

### 1.2 의존성 주입 원칙

```kotlin
// ❌ 나쁜 예 - 구체 클래스 의존
class UserService(
    private val userRepository: UserJpaRepository
) 

// ✅ 좋은 예 - 인터페이스 의존
class UserService(
    private val userRepository: UserRepository // 도메인 인터페이스
)
```

## 🎯 2. 코딩 컨벤션 & 스타일

### 2.1 네이밍 규칙

```kotlin
// 클래스명: PascalCase
class UserSyncService

// 함수명: camelCase, 동사로 시작
fun syncUserData()
fun validateRequest()

// 상수: UPPER_SNAKE_CASE
companion object {
    private const val MAX_RETRY_COUNT = 3
    private const val API_TIMEOUT_SECONDS = 30L
}

// Boolean: is/has/can 접두사
val isValidUser: Boolean
val hasPermission: Boolean
val canCreateRoadmap: Boolean
```

### 2.2 함수 작성 원칙

```kotlin
// ✅ 단일 책임 원칙 - 하나의 일만 수행
fun validateUserInput(request: CreateRoadmapRequest): ValidationResult {
    return when {
        request.companyId <= 0 -> ValidationResult.failure("잘못된 회사 ID")
        request.durationInMonths !in 1..12 -> ValidationResult.failure("기간은 1-12개월만 가능")
        else -> ValidationResult.success()
    }
}

// ✅ 조기 반환(Early Return) 패턴 활용
fun processUserSync(userId: Long): SyncResult {
    val user = userRepository.findById(userId) 
        ?: return SyncResult.failure("사용자를 찾을 수 없음")
    
    if (syncService.isInProgress(userId)) {
        return SyncResult.failure("동기화 진행 중")
    }
    
    return syncService.startSync(user)
}
```

### 2.3 Kotlin 관용구 활용

```kotlin
// ✅ 데이터 클래스 활용
data class ApiResponse<T>(
    val data: T? = null,
    val error: ApiError? = null,
    val pagination: Pagination? = null
)

// ✅ Sealed Class로 상태 표현
sealed class SyncStatus {
    object Idle : SyncStatus()
    data class InProgress(val progress: Int, val message: String) : SyncStatus()
    data class Completed(val completedAt: LocalDateTime) : SyncStatus()
    data class Failed(val error: String) : SyncStatus()
}

// ✅ Extension Function 활용
fun User.toResponse(): UserResponse = UserResponse(
    handle = this.solvedAcHandle,
    profileImageUrl = this.profileImageUrl,
    class = this.solvedAcClass,
    solvedCount = this.solvedCount
)
```

## 🛡️ 3. 에러 처리 전략

### 3.1 계층별 예외 처리

```kotlin
// 도메인 예외
sealed class DomainException(message: String) : RuntimeException(message) {
    class UserNotFoundException(userId: Long) : DomainException("사용자를 찾을 수 없습니다: $userId")
    class SyncInProgressException : DomainException("동기화가 진행 중입니다")
    class RateLimitExceededException : DomainException("API 호출 한도를 초과했습니다")
}

// 글로벌 예외 처리
@RestControllerAdvice
class GlobalExceptionHandler {
    
    @ExceptionHandler(DomainException.UserNotFoundException::class)
    fun handleUserNotFound(ex: DomainException.UserNotFoundException): ResponseEntity<ApiErrorResponse> {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(ApiErrorResponse(
                error = ApiError(
                    code = "USER_NOT_FOUND",
                    message = ex.message ?: "사용자를 찾을 수 없습니다"
                )
            ))
    }
}
```

### 3.2 Result 패턴 활용

```kotlin
// Result 래퍼 클래스
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Failure(val error: String, val cause: Throwable? = null) : Result<Nothing>()
    
    inline fun <R> map(transform: (T) -> R): Result<R> = when (this) {
        is Success -> Success(transform(data))
        is Failure -> this
    }
    
    inline fun onSuccess(action: (T) -> Unit): Result<T> {
        if (this is Success) action(data)
        return this
    }
}

// 활용 예시
class SolvedAcApiClient {
    suspend fun fetchUserData(handle: String): Result<SolvedAcUser> = try {
        val response = httpClient.get("/user/$handle")
        Result.Success(response.body())
    } catch (e: HttpException) {
        Result.Failure("API 호출 실패: ${e.message}", e)
    }
}
```

## 🔒 4. 보안 가이드라인

### 4.1 JWT 토큰 처리

```kotlin
@Component
class JwtTokenProvider(
    @Value("\${app.jwt.secret}") private val secret: String,
    @Value("\${app.jwt.expiration}") private val expiration: Long
) {
    
    fun generateToken(userDetails: UserPrincipal): String {
        return Jwts.builder()
            .setSubject(userDetails.userId.toString())
            .setIssuedAt(Date())
            .setExpiration(Date(System.currentTimeMillis() + expiration))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact()
    }
    
    // ❌ 절대 비밀키를 로그에 출력하지 마세요!
    // logger.debug("JWT Secret: $secret") // 위험!
}
```

### 4.2 입력값 검증

```kotlin
// ✅ Bean Validation 활용
data class CreateRoadmapRequest(
    @field:Positive(message = "회사 ID는 양수여야 합니다")
    val companyId: Long,
    
    @field:Min(value = 1, message = "최소 1개월")
    @field:Max(value = 12, message = "최대 12개월")
    val durationInMonths: Int
)

// ✅ SQL Injection 방지 - JPA 쿼리 사용
@Query("SELECT u FROM User u WHERE u.solvedAcHandle = :handle")
fun findByHandle(@Param("handle") handle: String): User?
```

## 🚀 5. 성능 최적화

### 5.1 데이터베이스 최적화

```kotlin
// ✅ N+1 문제 방지 - Fetch Join 활용
@Query("""
    SELECT r FROM Roadmap r 
    JOIN FETCH r.weeks w 
    JOIN FETCH w.problems p 
    WHERE r.userId = :userId
""")
fun findRoadmapWithDetails(@Param("userId") userId: Long): Roadmap?

// ✅ 페이징 처리
@Repository
class ReviewRepository {
    fun findReviewsByUserId(
        userId: Long, 
        pageable: Pageable
    ): Page<Review> = reviewJpaRepository.findByUserIdOrderByCreatedAtDesc(userId, pageable)
}
```

### 5.2 캐싱 전략

```kotlin
@Service
class CompanyService {
    
    // ✅ 자주 변경되지 않는 데이터는 캐시 활용
    @Cacheable(value = ["companies"], key = "'all'")
    fun getAllCompanies(): List<Company> {
        return companyRepository.findAll()
    }
    
    // ✅ 사용자별 데이터는 적절한 키로 캐시
    @Cacheable(value = ["user-dashboard"], key = "#userId")
    fun getUserDashboard(userId: Long): DashboardResponse {
        // 복잡한 집계 쿼리 실행
        return buildDashboardResponse(userId)
    }
}
```

## 🌐 6. 외부 API 통신 패턴

### 6.1 Resilience4j를 활용한 Circuit Breaker

```kotlin
@Component
class SolvedAcApiClient {
    
    @CircuitBreaker(name = "solvedac-api", fallbackMethod = "fallbackGetUser")
    @Retry(name = "solvedac-api")
    @TimeLimiter(name = "solvedac-api")
    suspend fun getUser(handle: String): SolvedAcUser {
        return webClient
            .get()
            .uri("/api/v3/user/show?handle={handle}", handle)
            .retrieve()
            .awaitBody<SolvedAcUser>()
    }
    
    // 폴백 메소드
    fun fallbackGetUser(handle: String, ex: Exception): SolvedAcUser {
        logger.warn("solved.ac API 호출 실패, 캐시된 데이터 사용: ${ex.message}")
        return getCachedUser(handle) ?: throw SolvedAcApiException("API 호출 실패")
    }
}
```

### 6.2 API 호출 로깅

```kotlin
@Component
class ApiCallLogger {
    
    suspend fun <T> logApiCall(
        apiName: String,
        operation: suspend () -> T
    ): T {
        val startTime = System.currentTimeMillis()
        return try {
            val result = operation()
            val duration = System.currentTimeMillis() - startTime
            logger.info("API 호출 성공: $apiName, 소요시간: ${duration}ms")
            result
        } catch (e: Exception) {
            val duration = System.currentTimeMillis() - startTime
            logger.error("API 호출 실패: $apiName, 소요시간: ${duration}ms, 에러: ${e.message}", e)
            throw e
        }
    }
}
```

## 🧪 7. 테스트 전략

### 7.1 테스트 피라미드 구성

```kotlin
// 단위 테스트 - Service 계층
@ExtendWith(MockKExtension::class)
class UserServiceTest {
    
    @MockK
    private lateinit var userRepository: UserRepository
    
    @MockK
    private lateinit var solvedAcClient: SolvedAcApiClient
    
    @InjectMockKs
    private lateinit var userService: UserService
    
    @Test
    fun `사용자 동기화 시 이미 진행중이면 예외 발생`() {
        // given
        val userId = 1L
        every { userRepository.isSyncInProgress(userId) } returns true
        
        // when & then
        assertThrows<SyncInProgressException> {
            userService.syncUserData(userId)
        }
    }
}

// 통합 테스트 - Repository 계층
@DataJpaTest
class UserRepositoryTest {
    
    @Autowired
    private lateinit var testEntityManager: TestEntityManager
    
    @Autowired
    private lateinit var userRepository: UserRepository
    
    @Test
    fun `핸들로 사용자 조회 성공`() {
        // given
        val user = User(solvedAcHandle = "goddold", solvedAcClass = 5)
        testEntityManager.persistAndFlush(user)
        
        // when
        val found = userRepository.findByHandle("goddold")
        
        // then
        assertThat(found).isNotNull
        assertThat(found!!.solvedAcHandle).isEqualTo("goddold")
    }
}
```

### 7.2 테스트 컨테이너 활용

```kotlin
@SpringBootTest
@Testcontainers
class ApiIntegrationTest {
    
    companion object {
        @Container
        @JvmStatic
        val postgresql = PostgreSQLContainer<Nothing>("postgres:13").apply {
            withDatabaseName("roadmap_test")
            withUsername("test")
            withPassword("test")
        }
    }
    
    @DynamicPropertySource
    companion object {
        @JvmStatic
        fun configureProperties(registry: DynamicPropertyRegistry) {
            registry.add("spring.datasource.url", postgresql::getJdbcUrl)
            registry.add("spring.datasource.username", postgresql::getUsername)
            registry.add("spring.datasource.password", postgresql::getPassword)
        }
    }
    
    @Test
    fun `사용자 생성 API 통합 테스트`() {
        // 실제 DB와 함께하는 통합 테스트
    }
}
```

## 📊 8. 로깅 & 모니터링

### 8.1 구조화된 로깅

```kotlin
@Component
class StructuredLogger {
    private val logger = LoggerFactory.getLogger(this::class.java)
    
    fun logApiRequest(
        userId: Long,
        endpoint: String,
        method: String,
        requestId: String = UUID.randomUUID().toString()
    ) {
        MDC.put("userId", userId.toString())
        MDC.put("requestId", requestId)
        MDC.put("endpoint", endpoint)
        
        logger.info("API 요청 시작: method={}, endpoint={}", method, endpoint)
    }
    
    fun logBusinessEvent(
        eventType: String,
        userId: Long,
        details: Map<String, Any>
    ) {
        val event = mapOf(
            "eventType" to eventType,
            "userId" to userId,
            "timestamp" to Instant.now(),
            "details" to details
        )
        
        logger.info("비즈니스 이벤트: {}", ObjectMapper().writeValueAsString(event))
    }
}
```

### 8.2 메트릭 수집

```kotlin
@Service
class UserService(
    private val meterRegistry: MeterRegistry
) {
    private val syncCounter = Counter.builder("user.sync.attempts")
        .description("사용자 동기화 시도 횟수")
        .register(meterRegistry)
    
    private val syncTimer = Timer.builder("user.sync.duration")
        .description("사용자 동기화 소요 시간")
        .register(meterRegistry)
    
    fun syncUserData(userId: Long): Result<Unit> {
        syncCounter.increment()
        
        return Timer.Sample.start(meterRegistry).use { sample ->
            try {
                // 동기화 로직 실행
                val result = performSync(userId)
                sample.stop(syncTimer.tag("status", "success"))
                result
            } catch (e: Exception) {
                sample.stop(syncTimer.tag("status", "failure"))
                throw e
            }
        }
    }
}
```

## 🔧 9. 설정 관리

### 9.1 환경별 설정 분리

```yaml
# application.yml
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:local}
    
app:
  jwt:
    secret: ${JWT_SECRET:default-secret-for-local}
    expiration: ${JWT_EXPIRATION:3600000}
  
  external-api:
    solved-ac:
      base-url: ${SOLVED_AC_BASE_URL:https://solved.ac/api/v3}
      timeout: ${SOLVED_AC_TIMEOUT:30s}
    openai:
      api-key: ${OPENAI_API_KEY:}
      model: ${OPENAI_MODEL:gpt-4}

# application-prod.yml
logging:
  level:
    com.roadmap: INFO
    org.springframework.security: WARN
```

### 9.2 설정 클래스

```kotlin
@ConfigurationProperties(prefix = "app.external-api.solved-ac")
@ConstructorBinding
data class SolvedAcProperties(
    val baseUrl: String,
    val timeout: Duration,
    val retryCount: Int = 3
)

@Configuration
@EnableConfigurationProperties(SolvedAcProperties::class)
class ExternalApiConfig {
    
    @Bean
    fun solvedAcWebClient(
        properties: SolvedAcProperties,
        builder: WebClient.Builder
    ): WebClient {
        return builder
            .baseUrl(properties.baseUrl)
            .defaultHeaders { headers ->
                headers.add("User-Agent", "RoadmapService/1.0")
            }
            .build()
    }
}
```

## 🚀 10. CI/CD & 배포 전략

### 10.1 Gradle 멀티모듈 구성

```kotlin
// settings.gradle.kts
rootProject.name = "roadmap-service"

include(
    ":domain",
    ":application", 
    ":infrastructure",
    ":presentation"
)

// 루트 build.gradle.kts
subprojects {
    apply(plugin = "org.jetbrains.kotlin.jvm")
    apply(plugin = "org.jetbrains.kotlin.plugin.spring")
    
    dependencies {
        implementation("org.jetbrains.kotlin:kotlin-reflect")
        implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
        testImplementation("org.springframework.boot:spring-boot-starter-test")
    }
    
    tasks.withType<Test> {
        useJUnitPlatform()
    }
}
```

### 10.2 Docker 최적화

```dockerfile
# Dockerfile
FROM openjdk:17-jdk-slim as builder

WORKDIR /app
COPY gradlew .
COPY gradle gradle
COPY build.gradle.kts settings.gradle.kts ./
COPY src src

RUN chmod +x ./gradlew
RUN ./gradlew build -x test --no-daemon

FROM openjdk:17-jre-slim

WORKDIR /app
COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app/app.jar"]
```

## 📋 11. 코드 리뷰 체크리스트

### 필수 확인사항
- [ ] **보안**: 민감 정보 하드코딩 없음
- [ ] **성능**: N+1 쿼리 문제 없음
- [ ] **예외처리**: 적절한 예외 처리와 로깅
- [ ] **테스트**: 핵심 비즈니스 로직 테스트 커버리지 80% 이상
- [ ] **로깅**: 적절한 로그 레벨과 구조화된 로깅
- [ ] **문서화**: API 변경사항 문서 업데이트

### 권장사항
- [ ] **가독성**: 함수는 20라인 이내, 클래스는 200라인 이내
- [ ] **재사용성**: 공통 로직의 유틸리티 함수화
- [ ] **확장성**: 인터페이스 기반 설계
- [ ] **모니터링**: 중요한 비즈니스 메트릭 추가

---

> **💡 마지막 조언**: 처음부터 완벽하게 하려고 하지 마세요. MVP부터 시작해서 점진적으로 개선하는 것이 실제 프로덕션에서는 더 효과적입니다. 특히 AI API 비용과 성능 모니터링은 초기부터 꼼꼼히 설정하세요!